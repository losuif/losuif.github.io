---
title: "[정처기] 데이터 입출력 구현 ② 물리 데이터 저장소 설계"
author: Jinsol
categories: 정보처리기사
tags: 정보처리기사
date: '2022-04-01'
# image: /assets/img/.png
---

<br>

# <span style="color:#8D8DAA">**👩‍💻 Ⅱ. 소프트웨어 개발**</span>
## <span style="color:#8D8DAA">**💻 1. 데이터 입출력 구현  2) 물리 데이터 저장소 설계**</span>
<hr>

<br> 
<br> 

### <span style="color:#8D8DAA">**🔎 물리 데이터 저장소**</span>
<hr>

- 물리 데이터 저장소란? 논리 데이터 모델을 사용하고자 하는 각 DBMS의 특성을 고려하여 데이터 베이스 저장 구조(물리 데이터 모델)로 변환하기 위한 데이터 저장소

- 물리 데이터 저장소 모델 변환 절차

    : 단위 개체를 테이블로 변환 -> 속성을 컬럼으로 변환 -> UID를 기본 키로 변환 -> 관계를 외래 키로 변환 -> 컬럼 유형과 길이 정의 -> 반 정규화(테이블 통합/테이블 분할/중복 테이블 추가/컬럼 중복화) 수행

- 물리 데이터 저장소 구성 : DBMS를 선정한 이후 물리 데이터 저장소 구성을 위한 활동

    - 테이블 제약조건(Constraint) 설계

        - 삭제 제약 조건(Delete Constraint)

            - 연쇄(Cascade) : 참조한 테이블에 있는 외부 키와 일치하는 모든 Row가 삭제

            - 제한(Restricted) : 참조한 테이블에 있는 외부 키에 없는 것만 삭제 가능

            - 무효(Nullify) : 참조한 테이블에 정의된 외부 키와 일치하는 것을 Null로 수정

        - 갱신 제약 조건(Update Constraint)

            - 연쇄(Cascade) : 참조한 테이블에 있는 외부 키와 일치하는 모든 Row가 수정

            - 제한(Restricted) : 참조한 테이블에 있는 외부 키에 없는 것만 수정 가능

            - 무효(Nullify) : 참조한 테이블에 정의된 외부 키와 일치하는 것을 Null로 수정 

    - 인덱스(Index) 설계

        - 인덱스 컬럼 선정

            - 분포도가 좋은 컬럼은 단독 생성

            - 자주 조합되어 사용되는 컬럼은 결합 인덱스로 생성

        - 설계 시 고려사항

            - 지나치게 많은 인덱스는 오버헤드(Overhead)로 작용

            - 인덱스는 추가적인 저장 공간이 필요햠

            - 넓은 범위를 인덱스 처리 시 오히려 전체 처리보다 많은 오버헤드를 발생시킬 수 있음

            - 인덱스와 테이블 저장 공간을 적절히 분리될 수 있도록 설계해야 함

    - 뷰(View) 설계

        - 뷰의 속성

            - REPLACE : 뷰가 이미 존재하는 경우 재생성

            - FORCE : 기본 테이블의 존재 여부에 관계 없이 뷰 생성

            - NOFORCE : 기본 테이블이 존재할 때만 뷰 생성

            - WITH CHECK OPTION : 서브 쿼리 내의 조건을 만족하는 행만 변경

            - WITH READ ONLY : 데이터 조작어 작업 불가

        - 뷰 설계 시 고려사항

            - 뷰 사용에 따라 수행속도에 문제 발생 가능

            - 뷰 SELECT문의 조건은 최적의 액세스 경로를 사용할 수 있도록 함

    - 클러스터(Cluster) 설계

        - 적용 기준

            - 인덱스의 단점을 해결한 기법으로, 분포도가 넓을수록 유리

            - 액세스 효율 향상을 위한 물리적 저장 방법

            - 분포도가 넓은 테이블의 클러스터링은 저장 공간의 절약이 가능

            - 대량의 범위를 자주 액세스 하는 경우 적용

            - 여러 개의 테이블이 빈번하게 조인을 일으킬 때 활용

        - 클러스터 설계 시 고려사항

            - UNION, DISTINCT, ORDER BY, GROUP BY가 빈번한 컬럼이면 검토 대상

            - 수정이 자주 발생하지 않는 컬럼은 검토 대상

    - 파티션(Partition) 설계

        - 파티션의 종류

            - 범위 분할(Range Partitioning) : 분할 키값이 범위 내에 있는지 여부를 구분하는 분할 기법

            - 해시 분할(Hash Partitioning) : 해시 함수의 값에 따라 파티션에 포함할지 여부를 결정하는 분할 기법

            - 목록 분할(List Partitioning) : 값 목록에 파티션을 할당하고 분할 키값을 그 목록에 맞게 분할하는 기법

            - 조합 분할(Composite Partitioning) : 범위,해시,목록 분할 중 2개 이상의 분할 기법을 결정하는 기법

            - 라운드로빈 파티셔닝(Round Robin Partitioning) : 파티션에 행의 고른 분포를 원할 때 사용

        - 파티션의 장점 : 성능 향상 / 가용성 향상 / 백업 가능 / 경합 감소

<br> 
<br> 

### <span style="color:#8D8DAA">**🔎 ORM 프레임워크**</span>
<hr>

- ORM 프레임워크(Object-Relational Mapping) 프레임워크란? 

    - 관계형 데이터베이스와 객체지향 프로그래밍 언어 간 호환되지 않는 데이터를 변환하는 프로그래밍 기법

    - 객체지향 언어에서 사용하는 객체를 관계형 데이터베이스로 변환하여 테이블을 구성하는 데 활용

- ORM 프레임워크 기술

    - SQL Mapping

        - iBatis : SQL에 기반한 데이터베이스와 자바, 닷넷, 루비 등을 연결시켜주는 역할을 하는 개발 프레임워크

        - MyBatis :  객체지향 언어인 자바의 관계형 DB 프로그래밍을 좀 더 쉽게 할 수 있게 도와주는 개발 프레임워크

    - OR Mapping

        - Hibernate : 자바 언어를 위한 객체 관계 매핑 프레임워크, 객체지향 도메인 모델을 관계형 데이터베이스로 매핑하기 위한 프레임워크 제공

<br> 
<br> 

### <span style="color:#8D8DAA">**🔎 트랜잭션 인터페이스**</span>
<hr>

- 트랜잭션 인터페이스(Transaction Interface)란? 데이터베이스 트랜잭션의 입출력과 기능 형태를 정의한 인터페이스

- 트랜잭션 인터페이스의 특징 - ACID 원칙을 기반으로 설계

    : 원자성(Atomicity) / 일관성(Consistency) / 격리성(Isolation) / 영속성(Durability)

- 트랜잭션 인터페이스 설계

    - 데이터 접근 방법 및 인터페이스를 절차적으로 명세

    - 주로 프로그래밍 언어로 구현됨

    - ex) JDBC(Java Database Connectivity), ODBC(Open Database Connectivity)