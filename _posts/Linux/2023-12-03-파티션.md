---
title: "[Linux] 파티션 / LVM, RAID / fdisk"
author: Jinsol
categories: Linux 리눅스
tags: Linux 리눅스
date: "2023-12-03"
# image: /assets/img/
---

<br>

# <span style="color:#FF90BC">🐧 파티션(Partition)</span>
<hr>

- <span style="color:#FF90BC">**하나의 물리적 디스크를 여러 개의 논리적인 디스크로 분할**</span>하는 것

- 다중 파티션의 장점

    - 부팅 시간 단축 : 파티션마다 독립적인 파일 시스템 운영 → 파일 점검 시간이 줄어듦
    
    - 높은 안정성 보장 : 특정 파티션의 파일 시스템이 손상되더라도 다른 파티션에 영향을 주지 않음
    
    - 백업 / 업그레이드 편리 : 필요한 파티션만 포맷 가능
    
- `/proc/partitions` 에서 파티션 상태 정보 확인

<br>
<br>

# <span style="color:#FF90BC">🐧 파티션의 종류</span>
<hr>

- **<span style="color:#FF90BC">주 파티션</span>**

    - 부팅이 가능한 기본 파티션

    - 하나의 하드디스크에 **최대 4개**의 주 파티션 분할 가능

- **<span style="color:#FF90BC">확장 파티션</span>**

    - 주 파티션 내에 생성하며, **하나의 물리적 디스크에 1개만** 생성

    - **1~4번 할당**
    
    - 데이터 저장 영역을 위한 것이 아니라 논리 파티션을 생성 

- **<span style="color:#FF90BC">논리 파티션</span>**

    - 확장 파티션 안에 생성
    
    - **5번 이후** 번호 할당 

- **<span style="color:#FF90BC">스왑 파티션</span>**

    - 하드디스크 일부를 메모리처럼 사용

    - 주 파티션 또는 논리 파티션에 생성

    - 프로그램 실행 시 부족한 메모리 용량 하드디스크로 대신함

    - 리눅스 설치 시 반드시 설치되어야 하는 영역

<br>
<br>

# <span style="color:#FF90BC">🐧 파일 시스템</span>
<hr>

- 운영체제가 파일을 시스템의 디스크 파티션상에 구성하는 방식

- 일정한 규칙을 가지고 파일을 저장하도록 규칙 방식 제시

- 파티션에 파일 시스템이 없으면 파일 시스템 생성을 거쳐야 사용이 가능함

<br>
<br>

# <span style="color:#FF90BC">🐧 LVM(Logical Volume Manager)</span>
<hr>

- **여러 개의 하드디스크를 합쳐서 사용하는 기술**로 한 개의 파일 시스템을 사용

- 작은 용량의 하드디스크 여러 개를 큰 용량의 하드디스크 한 개처럼 사용

- 서버 운영 시 대용량의 별도 저장 공간이 필요할 때 활용

- 다수의 디스크를 묶어 사용함으로써 파티션의 크기를 줄이거나 늘릴 수 있음

- "물리 볼륨"(여러 개의 물리적 하드디스크)를 합쳐서 > 하나의 물리적 그룹으로 만듦("볼륨 그룹") > 볼륨 그룹을 나눠서 다수의 "논리 볼륨"으로 나눔

<br>
<br>

# <span style="color:#FF90BC">🐧 RAID</span>
<hr>

- RAID(Redundant Array of Independent Disks, 복수 배열 독립 디스크)

- **여러 개의 물리적 디스크를 하나의 논리적 디스크로 인식하여 작동하게 하는 기술**

- 여러 개의 하드디스크에 일부 중복된 데이터를 나눠서 저장

- 안정된 시스템일수록 고가인 '하드웨어 RAID'와 저렴한 비용으로 안전한 데이터 저장이 가능한 '소프트웨어 RAID'

- RAID를 **구성하는 방식에 따라 저장 장치의 신뢰성과 전체적인 성능 및 용량**이 바뀌게 되며, 이 구성 방식을 **RAID Level**이라 함

<br>
<br>

# <span style="color:#FF90BC">🐧 RAID Level</span>
<hr>

- **<span style="color:#FF90BC">RAID 0</span>**

    - **스트라이핑 저장 방식** : 연속된 데이터를 여러 디스크에 나눠 저장

    - 최소 2개의 하드디스크 필요

    - 입출력 작업 모든 디스크에 동시에 진행 → 속도가 가장 빠르지만 하나의 디스크가 고장나면 전체 시스템 사용 불가
    
    - 주요 데이터 저장 부적합

- **<span style="color:#FF90BC">RAID 1</span>**

    - **미러링 방식** : 하나의 디스크에 데이터를 저장하면 다른 디스크에 동일한 내용이 백업되어 저장
    
    - 두 배의 용량 필요
    
    - 결함 허용을 제공하지만 공간 효율성 떨어짐
    
    - 주요 데이터 저장하기에 적절

- **<span style="color:#FF90BC">RAID 2</span>**

    - 스트라이핑 저장 방식

    - 기록용 디스크와 데이터 복구용 디스크 별도 제공

    - 오류 제어 기능이 없는 디스크를 위해 **해밍 코드** 사용

        - 해밍 코드? 데이터 비트에 몇 개의 패리티 비트가 추가된 코드

        - 수신된 데이터열에 에러 여부만 확인 할 수 있던 기존의 체크비트와 달리 에러비트의 위치를 알 수 있고 오류 정정도 가능함

    - 사용 효율성 낮음

- **<span style="color:#FF90BC">RAID 3</span>**

    - 스트라이핑 저장 방식

    - 오류 검출을 위해 **패리티 방식** 이용

        - 패리티 방식? 정보 전달 과정에서 오류 검출을 위해 데이터의 끝에 1비트를 더하여 전송하는 방법

        - 오류 발생 여부만 알 수 있고, 오류를 수정할 수 없고 2개 비트 오류 시 검출할 수 없다는 단점

    - 패리티 정보를 저장하기 위한 전용 디스크를 사용하기 때문에 최소 3개 이상의 하드디스크가 필요

    - 대형 레코드가 사용되는 단일 사용자 시스템에 적합

- **<span style="color:#FF90BC">RAID 4</span>**

    - RAID3와 유사하게 2개 이상의 데이터 디스크와 전용 패리티 디스크 사용
    
    - Byte 단위로 데이터를 저장하는 RAID 3와 다르게 Block(섹터) 단위로 데이터 저장

- **<span style="color:#FF90BC">RAID 5</span>**

    - 스트라이핑 저장 방식

    - 디스크마다 패리티 정보를 갖고 있어 패리티 디스크의 병목현상을 줄일 수 있음 → 실무에서 많이 사용

    - 디스크 섹터 단위로 저장

    - 쓰기 작업이 많지 않은 다중 사용자 시스템에 적합

- **<span style="color:#FF90BC">RAID 6</span>**

    - RAID 5를 확장한 것

    - Dual Parity를 사용하며, 최소 4개의 드라이브 필요

- <span style="color:#FF90BC">RAID 0+1</span>

    - 스트라이핑 방식 RAID 0과 미러링 RAID 1을 조합한 것

    - 미러링 전 스트라이핑 진행

    - 속도는 빠르나 데이터 복구 시간이 오래 걸림

- <span style="color:#FF90BC">RAID 1+0</span>

    - 미러링 후 스트라이핑 진행

    - 손실된 데이터만 빠른 복원이 가능

<br>
<br>

# <span style="color:#FF90BC">🐧 fdisk</span>
<hr>

- 파티션 테이블을 관리하는 명령어

-   - `a` : 부팅 파티션 지정
    
    - `l` : 파티션 종류 선택 시 리눅스에서 지원하는 파티션 목록 확인
    
    - `n` : 새로운 파티션 추가
    
    - `t` : 파티션 종류 변경
    
    - `w` : 파티션 정보 저장
    
    - `p` : 파티션 정보 확인
    
    - `q` : 작업 종료